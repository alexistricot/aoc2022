# Day 19 of the advent of code 2022

class Factory
    attr_accessor :cost, :blueprint, :robot_types

    def initialize(line)
        blueprint_re = /Blueprint (\d*):/
        ore_robot_re = /Each ore robot costs (\d*) ore\./
        clay_robot_re = /Each clay robot costs (\d*) ore\./
        obs_robot_re = /Each obsidian robot costs (\d*) ore and (\d*) clay\./
        geode_robot_re = /Each geode robot costs (\d*) ore and (\d*) obsidian\./
        @robot_types = %w[ore clay obs geode]
        # @cost[<robot type>][<resource>]
        @cost = {}
        @robot_types.each { |s| @cost[s] = {} }
        # parse input
        @blueprint = blueprint_re.match(line).captures.first.to_i
        @cost['ore']['ore'] = ore_robot_re.match(line).captures.first.to_i
        @cost['clay']['ore'] = clay_robot_re.match(line).captures.first.to_i
        @cost['obs']['ore'] = obs_robot_re.match(line).captures.first.to_i
        @cost['obs']['clay'] = obs_robot_re.match(line).captures.last.to_i
        @cost['geode']['ore'] = geode_robot_re.match(line).captures.first.to_i
        @cost['geode']['obs'] = geode_robot_re.match(line).captures.last.to_i
    end
end

class Blueprint
    attr_accessor :resources, :max_iter, :factory, :robots

    def initialize(line, max_iter)
        @factory = Factory.new(line)
        @robots = { 'ore' => [0], 'clay' => [], 'obs' => [], 'geode' => [] }
        @max_iter = max_iter
        # resources available after a certain number of iterations
        @resources = {}
        @factory.robot_types.each { |s| @resources[s] = Array.new(max_iter, 0) }
        @resources['ore'] = max_iter.times.to_a
    end

    def with_additional_robot(robot, iteration)
        # build a new robot at iteration
        bp = Blueprint.allocate
        bp.factory = @factory
        bp.max_iter = @max_iter
        bp.robots = {}
        @robots.each_pair { |res, array| bp.robots[res] = array.dup }
        bp.resources = {}
        @resources.each_pair { |res, array| bp.resources[res] = array.dup }
        # build the robot
        bp.robots[robot].push(iteration)
        # spend resources to build the robot
        @factory.cost[robot].each_pair do |res, cost|
            # puts "Building robot #{robot} at iteration #{iteration}"
            bp.resources[res][iteration..] = bp.resources[res][iteration..].map { |n| n - cost }
        end
        # add future resources generated by the robot
        future_res = (@max_iter - iteration).times.to_a
        bp.resources[robot][iteration..] = bp.resources[robot][iteration..].add(future_res)
        # bp.print(iteration)
        bp
    end

    def when_affordable(robot, iteration)
        # durations from the current iteration until we have enough of each resource to build the robot
        durations = @factory.cost[robot].to_a.map do |res, cost|
            # array is be sorted after iteration because it's only resources accumulating, no spending
            if @resources[res][-1] < cost
                # robot is never affordable
                nil
            else
                @resources[res][iteration..].bsearch_index do |i|
                    # first index where there is enough resources to build the robot
                    i >= cost
                end
            end
        end
        # return if one of the resources will never be available
        return nil if durations.map(&:nil?).any?

        # we can build a robot when all the resources are available, at the start of the next minute
        result = iteration + 1 + durations.max

        result < @max_iter ? result : nil
    end

    def print(iteration)
        puts "Blueprint #{@factory.blueprint}, iteration #{iteration}/#{@max_iter}"
        puts "Robots:#{@robots.to_a.map { |robot, n| " #{robot}: #{n}" }.join(',')}"
        @resources.each_pair do |res, arr|
            puts "#{res}[0..#{arr.length}]: #{arr.join(',')}"
        end
        puts
    end
end

class Array
    def add(arr)
        zip(arr).map { |x, y| x + y }
    end
end

def extract_geodes(bp, iteration, max_iter, visited)
    # we reached the end of iteration
    return bp.resources['geode'][bp.max_iter] if iteration >= max_iter

    next_robots = bp.factory.robot_types.map do |robot|
                      [robot, bp.when_affordable(robot, iteration)]
                  end.reject { |_robot, iter| iter.nil? }

    return bp.resources['geode'][bp.max_iter - 1] if next_robots.empty?

    return visited[[iteration, bp.robots]] if visited.keys.include?([iteration, bp.robots])

    # puts "Iteration #{iteration}: next_robots: #{next_robots.map { |robot, cost| "(#{robot},#{cost})" }.join(' ; ')}"
    # bp.print(iteration)

    next_robots.map do |robot, new_iteration|
        # puts "Adding robot #{robot} at #{new_iteration}"
        new_robot = bp.with_additional_robot(robot, new_iteration)
        visited[[new_iteration, new_robot.robots]] = extract_geodes(new_robot, new_iteration, max_iter, visited)
        visited[[new_iteration, new_robot.robots]]
    end.max
end

input = File.read('./inputs/day19.test.txt').split("\n")
max_iter = 24 + 1

visited = {}
puts input.map.with_index { |line, idx|
    extract_geodes(Blueprint.new(line, max_iter), 0, max_iter, visited) * (idx + 1)
}.sum
